---
layout: page
title: "Раздел 4 - Хранение состояния"
permalink: content-04
---

## Особенности работы протокола HTTP

Как вы узнали из прошлой главы, работа с веб-сайтами в интернете происходит по протоколу HTTP.  
Это замечательный и простой протокол, который действует по схеме "запрос-ответ". Т.е. клиент (браузер)
пользователя посылает на сервер запрос, состоящий, как правило, только из заголовков, а затем получает
ответ в виде заголовков ответа и тела самого документа.  
В отличие от многих других протоколов, HTTP не сохраняет своего состояния.
Это означает отсутствие сохранения промежуточного состояния между парами "запрос-ответ".  
Иными словами, сервер не "запоминает" клиентов; каждый запрос он обрабатывает с "чистого листа".

Для сервера нет никакой разницы: запросил один пользователь страницу десять раз или десять разных пользователей
по разу. Для него все запросы одинаковые.  

Чем это неудобно для нас?  
Часто сайты должны уметь идентифицировать своих посетителей, чтобы сохранять и показывать им позже какую либо
  информацию.  
Например, интернет-магазины могут сохранять историю просмотров, чтобы рекомендовать потенциальным покупателям
наиболее подходящие им товары.  Или агрегатор новостей мог бы предложить пользователям выбирать только
интересующие их рубрики.  

К счастью, протокол HTTP, а также все браузеры предоставляют возможность сохранения информации о пользователе

## Cookies

Cookies (в дальнейшем просто "куки") - небольшие фрагменты данных, которые веб-сервер отправляет браузеру.  
Браузер сохраняет их у себя, а при следующем посещении веб-страницы отправляет обратно. Благодаря этому, веб-сервер
сможет узнать своего "старого" посетиля, идентифицировать его.  

С технической стороны, куки - это обычные HTTP заголовки.  
Когда веб-сервер хочет записать куку в браузер пользователя, то он отсылает специальный заголовок ответа с названием
`Set-Cookie`. В этом заголовке должна содержаться непосредственно необходимая информация, а также дополнительные
аттрибуты, о которых пойдет речь далее.  
В следующий раз, когда браузер пользователя запросит веб-страницу с того же сайта, в числе прочих заголовков он
передаст заголовок запроса `Cookie`.  Веб сервер получит эту информацию и она будет доступна также и для PHP.

### Пример
Задача очень проста: сохранять и показывать посетителю страницы сколько раз он посетил наш сайт. Для этого будем
сохранять количество посещений в отдельной куке, увеличивая значения на единицу при каждой загрузке страницы.

### Как установить куки
Являясь серверным языком программирования, PHP может управлять заголовками, которые отправляет сервер, а значит
может устанавливать и читать куки.  
Чтобы добавить новую куку, необходимо вначале определиться со следующими критериями:
* название этой куки (может состоять только из символов латинского алфавита и цифр)
* значение, которое предполагается хранить
* срок жизни куки - это обязательное условие

За установку куки в PHP отвечает функция `setcookie`, ей нужно передать как минимум три параметра, описанных выше.
Пример:
```
<?php
setcookie("visit_count", 1, strtotime("+30 days"));
```
Обратите внимание, что срок жизни указывается в относительной величине. В этом примере кука будет существовать ровно
30 дней с момента установки.

### Как прочитать куки
В PHP максимально упрощен процесс чтения информации из кукисов.
Все переданные сервером куки становятся автоматически доступны в специальном глобальном массиве `$_COOKIE`  
Так, чтобы получить содержимое куки с именем "visit_count", достаточно обратиться к одноименному элементу массива
`$_COOKIE`, например вот так:
```
<?php
print($_COOKIE["visit_count"]);
```

Обратите внимание: установив в сценарии куку через `setcookie`, прочитать её можно будет только при следующем посещении
страницы.

### Собираем все вместе
Теперь, научившись устанавливать и читать куки, напишем полноценный сценарий, который будет считать и выводить количество
посещений страницы пользователем:

```
<?php
$visit_count = 1;

if (isset($_COOKIE["visit_count"])) {
    $visit_count = $_COOKIE["visit_count"] + 1;
}  

setcookie("visit_count", $visit_count, strtotime("+30 days"));

print("Количество посещений: " . $visit_count);
```

## Сессии
Мы уже умеем сохранять информацию для пользователя между посещениями страницы с помощью кук. Но зачем же нам еще сессии и
для чего они нужны?  
Сессии, они же сеансы, это, по сути, просто удобная обертка над куками. Они также позволяют хранить данные, релевантные
 пользователю, но с некоторыми отличиями и ограничениями:
* Данные хранятся не произвольное время, а только до закрытия вкладки с веб-страницей
* Чтобы сессии работали, в начале каждого сценария надо вызывать функцию `session_start()`
* Доступный объем для хранения информации намного больше

Используя сессии, запись и чтение информации происходит просто как работа со специальным массивом `$_SESSION`

### Как устроены сессии
1. PHP генерирует уникальный идентификатор браузера
2. Идентификатор сохраняется в специальную куку и передается с каждым запросом
3. Все данные, которые записываются в сессию, PHP автоматически сохраняет в специальном файле на сервере

Благодаря существованию сессий в PHP, мы можем сохранять любые данные так же просто, как присваивать их переменным. Но,
в отличие от переменных, эти данные будут сохраняться для пользователя между запросами в пределах сеанса.  

Перепишем сценария для подсчета посещений, но теперь используем сессии:
```
<?php
session_start();
$visit_count = 1;

if (isset($_SESSION["visit_count"])) {
    $visit_count = $_SESSION["visit_count"] + 1;
}

$_SESSION["visit_count"] = $visit_count;

print("Количество посещений: " . $visit_count);
```

## Аутентификация
Представим условный интернет-магазин. Все его страницы можно разделить на две половины: публичные и приватные.  
К публичным относятся страницы каталога, информации о товаре, условия доставки и т.д. К приватным - корзина покупок,
история заказов.  
Совершенно очевидно, что корзина покупок у каждого покупателя должна быть своя, а иметь к ней доступ должен только сам
владелец и никто больше.  

Процедура проверки возможности доступа пользователя к определенной части сайта и называется аутентификацией.  
Весь процесс аутентификации всегда состоит из нескольких шагов:
1. При попытке доступа к закрытой части сайта, пользователь видит форму, где он должен ввести свой логин и пароль
2. Форма отправляется, а полученные данные сравниваются с действительным логином и паролем существующего пользователя
3. Если данные совпадают, то пользователь считается аутентифицированным и получает доступ к приватной части сайта
4. При повторном открытии этой страницы пользователь не должен повторно вводить пароль, если он уже делал это в рамках
текущего сеанса

PHP предлагает два подхода для реализации такой аутентификации.

### Базовая HTTP-аутентификация
Это самый простой способ организовать аутентификацию пользователей на своем сайте.  
Он заключается в том, что мы посылаем специальный заголовок - `WWW-Authenticate`.  Встретив этот заголовок,браузер
 автоматически покажет форму с требованием ввести логин и пароль.  Отправка формы повторно вызывает сценарий, но в этот
 раз в нем будут предопределены несколько переменных, которые будут содержать логин и пароль, введенные пользователем.  
РНР-сценарий может проанализировать имя пользователя и его пароль, введенные в окне диалога аутентификации, и на основании
результатов такого анализа принять решение либо о предоставлении этому пользователю доступа к защищенной странице,
либо об отклонении запроса.

Удобство этого метода состоит еще и в том, что браузер пользователя сам запоминает и каждый раз передает введенные
однократно логин с паролем, что избавляет нас от необходимости самостоятельно хранить эту информацию с помощью сессий
или кук.


### Веб-аутентификация
Базовая HTTP-аутентификация имеет и свои недостатки:
* это не очень безопасно
* внешний вид формы аутентификации никак не настраивается, т.к. выводится браузером самостоятельно
* нет возможности добавить дополнительные поля

По этим причинам гораздо чаще используется веб-аутентификация. Этот подход требует намного больше ручной работы,
но взамен мы получаем значительные возможности для настройки.
