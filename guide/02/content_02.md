---
layout: page
title: "Раздел 2 - Заканчиваем с азами"
permalink: content-02
---

## Продолжаем изучать синтаксис языка

### Массивы

Массив - это способ хранить в одной переменной множество значений.  
В предыдущих примерах всегда имя переменной ассоциировалось только с одним значением:
* `$name = "Иннокентий"`
* `$age = 42`

Но можно точно также запоминать под одним именем больше одного значения.
Что если мы хотим узнать у нашего пользователя не только его пол, имя и возраст, но и, допустим, любимые сериалы. 
Очень непросто назвать один самый любимый сериал, а вот вспомнить несколько - намного легче.
Вот так выглядит сохранение в переменную нескольких значений:
`$fav_shows = ["game of thrones", "american horror storry", "walking dead"]`  

В этом примере мы сохранили в переменной `$fav_shows` сразу три значения. Но сохранить эти данные - это только пол дела, 
как их показать?  
Первое, что приходит в голову, использовать уже знакомый способ вывода переменной на экран:
```
<?php
print("Мои любимые сериалы: " . $fav_shows);
```
К сожалению, такой способ с массивами работать не будет, т.к. массив не совсем обычная переменная.
Массив хранит не простые типы, вроде текста или чисел (их еще называют "скалярными типами"), а более сложную структуру 
данных, поэтому здесь нужен особый подход.  

Внутри массива у каждого из значений есть свой цифровой индекс, по которому к нему можно обратиться. Этот индекс 
является своеобразным внутренним адресом, как бы дополнительным именем, которое добавляется к имени переменной.
Индексация начинается с нуля, так что первый элемент получает индекс - "0", второй - "1" и так далее.  

Итак, чтобы получить определенный элемент массива, необходимо знать его индекс (ключ).
Вот как будет выглядеть вывод списка всех сериалов через запятую:
```
<?php
print("Мои любимые сериалы: " . $fav_shows[0] . ", " . $fav_shows[1] . ", " . $fav_shows[2]);
```
Теперь можно дать определение массива:  
*Массив - это совокупность множества элементов вида "ключ : значение".*

Массивы позволяют также перезаписывать любые имеющиеся значения, а также добавлять новые.
Чтобы добавить в массив новое значение, следует использовать такую инструкцию:
`$fav_shows[] = "the big bang theory"`  
Новодобавленный элемент автоматически получит индекс, равный максимальному индексу из имеющихся + 1. Т.е. в нашем случае, "теория большого взрыва" сохранится под индексом 4.

Перезаписать уже имеющееся значение тоже позволительно.
Вдруг нам перестал нравиться один из сериалов, т.к. новый сезон оказался очень плох, или появился новый фаворит.
Вычеркнуть старое значение и заменить его новым можно просто присвоив новое значение любому из имеющихся в массиве индексов:
`$fav_shows[4] = "fargo"`

Для полного удаления (без замены на другое) одного из значений по его индексу есть функция `unset`:
`unset($fav_shows[4])`

#### Ассоциативные массивы

Ассоциативные массивы отличаются от простых только одним - в качестве ключей в них могут быть не
порядковый индекс-цифра, а строка. Что это значит?  
Мы уже знаем достаточно много о нашем гипотетическом пользователе: его имя, возраст, любимый цвет и сериалы. Было бы 
очень удобно сохранить все эти данные внутри одной переменной!  
Именно в такой ситуации мог быть полезны ассоциативные массивы.

Запись всей информации о пользователе с помощью ассоциативного массива:
```
<?php
$user = ['age' => 42, 'name' => 'Иннокентий', 'fav_shows' => ["game of thrones", "american horror storry", "walking dead"] ];
```

Обратите внимание, что массив может содержать массивы в качестве своих значений. В нашем примере мы записали обычный 
массив внутрь ассоциативного под ключом "fav_shows".

Вывод информации из ассоциативных массивов аналогичен.  
Показ всей информации о пользователе, сохраненном в переменной $user:
```
<?php
print("Имя: " . $user['name'] . " Возраст: " . $user['age'] . "
Любимые сериалы: "  . $user['fav_shows'][0] . ", " . $user['fav_shows'][1] . ", " . $user['fav_shows'][2];
```

### Циклы
Цикл - это конструкция языка, которая позволяет выполнить некий блок кода больше одного раза.

Мы привыкли, что наши сценарии выполняются линейно: сверху вниз, строчка за строчкой, инструкция за интструкцией. Но как 
быть, если хочется повторить какую нибудь инструкцию несколько раз?  
Например, нам внезапно захотелось вывести на экран натуральные числа (1...9).  
Конечно, никто не мешает сделать это очевидным способом, например так:
```
<?php
print (1);
print (2);
print (3);
// и так далее...
```

Но, во первых, такой способ заставляет писать много кода. Во-вторых: что если мы хотим вывести последовательность из 
миллиона чисел? И, наконец, бывают ситуации, когда заранее нам неизвестно сколько раз требуется выполнить определенную
 инструкцию...  

Использование циклов значительно упрощает и укорачивает код, а также дает возможность выполнять нужный блок кода то 
количество раз, которое может зависеть от условий и неизвестно в момент написания сценария.

В PHP цикл реализуется такой синтаксической конструкцией:
```
<?php
while (<условие цикла>) {
<тело цикла>
}
```
Из прошлой главы, в разделе, посвященном условиям, вы уже познакомились с таким понятием, как выражение и его истинность.
Так и здесь: выражение, которое находится в части <условие цикла> определяет, будет ли исполнен блок кода - <тело цикла>. 
Если условие цикла возвращает истину, то выполнение перейдет к блоку "тело цикла", если же оно вернет ложь - то тело 
цикла исполнено не будет и сценарий продолжит выполняться как обычно, со следующей строки после цикла.  

Т.е. циклы как бы "зацикливают" обычное, линейное исполнение на своем блоке кода и не дают сценарию выполняться дальше, 
пока условие цикла будет иметь значение "истина".  
Очень важно понимать последовательность, в которой исполняется код при использовании циклов.
1. Обычное исполнение кода, строчка за строчкой, пока не встретился цикл
2. Встретился цикл: выполняем условие цикла
3. Если условие вернуло ложь: выходим из цикла, выполняем строчку после него и продолжаем линейное исполнение
3. Если условие вернуло истину: выполняем всё тело цикла
4. Повторяем пункт 2

Каждая последовательность из шагов 2-4, т.е. очередное выполнение блока кода в теле цикла - называется итерацией.  

Очевидно, что количество итераций должно быть конечным, т.е., как правило, бесконечное выполнение одного блока кода не 
входит в наши планы.  
А значит, чтобы написать правильный цикл, необходимо заранее предусмотреть ситуацию, когда истинное условие станет
 ложным в нужный для нас момент.  
Как все это можно использовать в нашей задаче по показу всех натуральных чисел?  
```
<?php
$last_num = 1;

while ($last_num < 10) {
    print($last_num);
    $last_num = $last_num + 1;
}
```
В этом примере, блок кода выводящий на экран цифру, а затем прибавляющий к ней единицу, будет исполнен ровно десять раз, 
потому что на одиннадцатый раз значение переменной `$last_num` станет равно десяти и условие `$last_num < 10` перестанет
 быть истинным.

#### Циклы и массивы

Чаще всего циклы используются вместе с массивами. А конкретнее - для перечисления всех элементов массива и выполнение 
какого либо действия с каждым значением.  
Зная, как работать с циклами и массивами вы уже становитесь способными выполнять очень большое число самых разнообразных
 задач!  

В примере выше мы учились работе с массивами и узнали как показать все значения массива, обратившись к каждому из элементов
 по его индексу. Но обращаться к каждому из элементов массива по очереди, когда мы хотим вывести всего его значения - 
 черезчур утомительно. Особенно, когда число элементов в нем исчисляется не единицами, а сотнями и даже тысячами!  
Циклы помогут нам показать содержимое любого массива, обратившись к каждому из его элементов и всё это потребует всего
 нескольких строчек кода!  

Перепишем пример с выводом списка любимых сериалов, но теперь используя цикл.
```
<?php
$fav_shows = ["game of thrones", "american horror storry", "walking dead"];
$cur_index = 0;

while ($cur_index < 3) {
    print($fav_shows[$cur_index] . ", ");
    $cur_index = $cur_index + 1;
}
```
В новом примере наш цикл выводит элемент по индексу, который теперь задан в переменной $cur_index, и начальное значение 
у него 0, но оно увеличивается на единицу с каждой итерацией цикла, пока, наконец не достигнет трех и тогда условие 
`$cur_index < 3` перестанет быть истинным.

### Функции
Если говорить просто, то функция - это блок кода, подпрограмма, которая может быть именована и вызывана повторно.  
Т.е. если обычной переменной можно назначить число или строку, а затем обратиться к этому значению по имени, то функция 
- это тоже своего рода переменная, только вместо строки или числа, в ней хранится блок кода, который будет вызван при 
использовании этой переменной.

Создав пользовательскую функцию, вы можете использовать ее код столько раз, сколько вам это нужно, без необходимости 
каждый раз переписывать один и тот же код.

Чтобы упростить себе работу, мы можем оформить некоторую часть кода, которая используется несколько раз в нашем сценарии
 в виде функции, а затем, вместо копирования и вставки этой части кода, будет достаточно только вызывать эту функцию, 
 как если бы мы обращались к переменной.

Разделяют два типа функций - встроенные и пользовательские.

Встроенные функции - это функции, которые за нас уже написали создатели языка программирования и мы можем просто их
 использовать.
Так, в PHP существуют тысячи функций на все случаи жизни!
Одна из таких уже очень хорошо знакомых нам функций - это функция, которая выводит переданный ей текст на экран - `print()`

Пользовательские функции - это те функции, которые создаете вы сами, если вам не хватает возможностей, предлагаемых 
языком или вы хотите оформить часть своего кода в такую функцию.

#### Анатомия функций
Как и с обычными переменными, работа с функциями состоит из их объявления и использования.  
Перед тем как использовать новую функцию, следует её объявить:  
```
<?php
function <имя функции>(<аргумент функции>) {
    <тело функции>
    return <результат выполнения функции>;
}
```
Пояснить все составные части функции проще всего на примере.  
На своем сайте мы хотим показывать, является ли переданный пользователем год високосным. Будет правильным написать
 функцию, которой передается год, а в ответ мы ожидаем получить значение "истина", если год високосный, и "ложь" - 
 если нет.  
Определение такой функции:
```
<?php
function is_leap_year($year) {
    if ($year % 4 != 0) {
        return false;
    elseif ($year % 100 == 0) {
        if ($year % 400 == 0) {
            return true;
        }
        else {
            return false;
        }
    }
    else {
        return true;
    }
}
```

Пример использования функции:
```
<?php
$year = 2034;

if (is_leap_year($year)) {
    print("2034 год - простой");
}
else {
    print ("2034 год - високосный");
}
```

##### Аргументы функции и область видимости
Наша функция умеет вычислять, является ли год, который ей передали, високосным.  
Важно понимать, что функция - это как бы программа в программе, вещь в себе. Это значит, что внутри такой функции не 
будут доступны переменные, которые были определены за её пределами. Чтобы передать внутрь функции информацию извне - 
нужно использовать аргументы функции.  

*Аргументы функции* - это переменные, которые функция может получить извне. При определении функции мы именуем 
переменные, которые функция может получить из внешнего кода. В примере с `is_leap_year` такая переменная была только 
одна - $year.  

Аргументы нужны, т.к. функция "не видит" переменные, определенные за её границами, поэтому нужные переменные надо 
передавать ей явно.  
Верно и обратное - переменные, определенные внутри функции, не будут доступны извне. Такие переменные называются
 локальными, потому что они локальны по отношению к функции.  
В отличие от аргументов, которых может быть несколько, вернуть во внешний код функция может только одно значение - 
с помощью инструкции "return" (возврат).