---
layout: page
title: "Объекты и использование библиотек"
permalink: libraries.html
---
# Объекты

Объекты в PHP - это просто еще один тип данных. Объект позволяет хранить в переменной набор из свойств-значений, а также встроенные функции. Это делает объекты похожими по своей структуре с знакомыми ассоциативными массивами. Но отличие от массивов все таки имеется и при этом достаточно важное - объекты могут иметь внутреннее состояние. 

## Особенности объектов и их отличия от массивов

Давай разберемся что такое PHP-объект. Как сказано выше, объекты похожи на массивы, но со своими особенностями. Объекты могут содержать отдельные значения, каждое под своим ключом. Такие значения называются свойствами объекта.  
Также объекты могут иметь внутри себя функции – их называют методами объекта. Методы могут обращаться к любым свойствам объекта, читать и записывать туда данные.  

Значение свойства объекта может быть любого типа: число, строка, массив, другой объект. Но, в отличие от массива, объекты не позволяют добавлять в себя новые значения. Т.е. объект всегда имеет конечное число своих свойств и методов. Менять значения существующих свойств можно, а удалять и заменять их – нельзя. Что в корне отличается от поведения массива, ведь там добавлять и удалять значения можно в любое время.  

Но самая большая особенность объектов - это то, как они создаются. Вспомним массив. Массив создается либо пустым, либо сразу с набором значений. Объекты устроены иначе. Дело в том, что объекты не существуют сами по себе. Чтобы создать новый объект, вам придется вначале создать его описание – класс.  
Класс – это как бы чертеж объекта. Класс описывает из чего состоит объект. Мы разберем классы чуть позже.

## Анатомия объекта

Как же устроен объект изнутри? Содержимое объекта можно поделить на две группы: свойства и методы.  
Свойства могут быть двух видов: публичные и скрытые. К публичным свойствам можно обращаться за пределами объекта, точно также как вы обращаетесь к элементам массива по его ключам.  
Скрытые же свойства не имеют аналогов в массиве. Скрытые свойства доступны для чтения и изменения только внутри самого объекта – это могут делать его методы.

Вторая группа – это методы объекта.  
Набор методов также называется поведением объекта. Как и свойства, методы бывают публичными и скрытыми. Публичные методы объекта можно вызывать из внешнего кода, а скрытые только из самого объекта.
Методы способны свободно обращаться к свойствам объекта также просто, как если бы это были их внутренние переменные или аргументы. 

# Классы

Класс - это шаблон, по которому создаются объекты.  

Напомню, что классы – это описания объектов. Мы не можем создать объект «на лету», как это происходит с массивами. Объект может быть создан только на основе своего описания – класса. Этим, кстати, реализация объектов в PHP отличается от JavaScript. В JS объектам не нужны никакие классы, и они могут быть созданы и модифицированы, когда угодно и, как угодно.

## Класс как чертёж

Зачем же нужны классы и почему объекты не могут существовать без них?  

Здесь аналогия очень простая: класс – это чертеж, максимально подробное описание того, как должно выглядеть изделие. Сам по себе класс не является чем-то физическим и осязаемым, т.е. мы не можем использовать его в коде непосредственно. Вместо этого класс является схемой, структурой, на основе которой будет создан объект. 

## Жизненный цикл объекта

Вот из каких этапов состоит любая работа с объектами в PHP.  
Начинается все с создания класса. В классе мы фиксируем из каких свойств и методов будет состоять каждый его экземпляр. Также в классе можно задать начальные значения для каждого свойства.  
Имея класс, возможно создать его экземпляр – объект. 

Классы в PHP принято сохранять в отдельных файлах, поэтому вначале вы подключаете этот сценарий там, где он вам необходим. Затем вызываете процедуру создания нового объекта на основе этого класса.  

Чтобы использовать объект в дальнейшем, его следует, как всегда, назначить переменной. Затем вы будете через переменную работать с объектом: вызывать его методы и обращаться к его свойствам.

## Пример создания объекта на основе класса

Описание класса:  

```
class WeatherEntry
{

    private $date;
    private $comment = "";
    private $temperature = 0;

    private $isRainy = false;

    public function __construct($date, string $comment, int $temperature)
    {
        $this->date = $date;
        $this->comment = $comment;
        $this->temperature = $temperature;
    }

    public function isCold()
    {
        return $this->temperature < 0;
    }

    public function setRainStatus($rain_status)
    {
        $this->isRainy = $rain_status;
    }

    public function getDayDescription()
    {
        $dt = strtotime($this->date);
        $delta = time() - $dt;
        $days = ceil($delta / 86400);

        $res = "Это было $days дней назад. В тот день было ";

        if ($this->isCold()) {
            $res .= "холодно. ";
        }
        else {
            $res .= "довольно тепло. ";
        }

        if ($this->isRainy) {
            $res .= "Семенил дождь.";
        }
        else {
            $res .= "На небе не было ни облачка.";
        }

        return $res;
    }
}
```

Создание объекта на основе класса: 
```
$firstSeptember = new WeatherEntry("2018-09-01", "День знаний", 14);
$firstSeptember->setRainStatus(false);

print($firstSeptember->getDayDescription());
```

## Разбор примера

Разберёмся с тем, что здесь происходит.  
Начнём с целей создания данного класса. Его задача - хранить в объекте данные о погоде за конкретный день, а также предоставлять сводку за этот день в текстовом виде.  

В классе определенно четыре скрытых свойства. Это значит, что к ним не будет доступа за пределами объекта. Читать и записывать эти свойства могут только внутренние методы объекта. Сами свойства хранят температурные свойства (величина температуры, осадки), дату и дополнительный комментарий к записи. Некоторым свойствам задано значение по умолчанию.  

Далее идёт перечисление методов. И начинается всё с метода, у которого особое имя и значение - `__constructor`.

### Что такое конструктор объекта 

Методы объекта вызываются из внешнего кода, при явном к ним обращении с указанием имени. Но если назвать один метод `__constructor` то он будет вызываться автоматически **в момент создания объекта** на основе класса.  

Конструкторы объектов используются для инициализации каких либо значений и выполнении других подготовительных операций. В нашем примере конструктор устанавливает содержимое скрытых свойств.

### Обращение к свойствам и методам объекта

Посмотрим как внутри метода происходит обращение к его свойствам.  
Во-первых, для этого используется специальная переменная this которая всегда присутствует внутри объекта и ссылается на него самого.  

Во-вторых, для обращения к методам и свойствам объекта нужен специальный синтаксис: «стрелочка». Такая стрелочка отделяет имя свойства или метода от имени объекта. Это аналог квадратных скобок при работе с массивами.

Метод с именем `isCold()` нужен, чтобы узнать было ли холодно в тот день, основываясь на показаниях температуры в градусах.  
Метод `setRainStatus()` устанавливает логическое значение, которое показывает статус осадков на день наблюдения.  
И наконец метод `getDayDescription()` формирует текстовое описание погоды на заданную дату.

### Создание объекта на основе класса

Написав класс, мы выполнили львиную часть из всего необходимого. Теперь нам предстоит создать новый объект на основе этого класса и показать, как с ним работать.  
Новый объект создается с помощью ключевого слова new, после которого идет имя его класса. В круглых скобках надо передать все аргументы в метод construct, когда такой имеется. Класс не обязан содержать этот метод, поэтому в таком случае круглые скобки не обязательны.  

В коде мы передаем в конструктор почти все параметры погодных наблюдений. Затем уже для созданного объекта вызыаваются его методы: первый устанавливает осадки, а второй возвращает текстовое описание погоды.

# Библиотеки

Библиотека - это программный код, оформленный в виде отдельного компонента, который можно использовать для решения изолированной задачи.  

## Назначение библиотек

Профессиональный программист не будет писать весь код самостоятельно. Уровень разработчика определяется не только его знанием языка, но и умением искать и выбирать подходящие инструменты для решения конкретной задачи. Если есть возможность использовать качественное готовое решение, то это будет лучшим выбором.  

Готовые решения помогают писать меньше кода и сосредоточиться на предметной области проекта. Большинство библиотек свободно распространяются в интернете и доступны для бесплатного использования.  

Обычно библиотека – это набор PHP-сценариев, запакованных в архив. При установке файлы распаковываются из архива в определенную папку внутри вашего проекта. Как правило, один проект использует минимум несколько библиотек.

## Когда использовать библиотеку

Когда следует использовать и как выбрать подходящую для ваших целей библиотеку?  

Готовые решения предназначены для упрощения работы над распространенными задачами. Это базовые операции, которые часто встречаются практически в любом веб-проекте.  
Примеры: отправка сообщений электронной почты, валидация форм, работа с графикой, ресайз изображений, работа с архивами.  
Поэтому, естественно, библиотеки не заменят весь код вашего проекта, но возьмут на себя большую часть рутинных действий. 

Следующее на что стоит обратить внимание при выборе библиотеки – это наличие хорошей документации.  
Документация описывает возможности библиотеки и способы её использования. Если документация неполная, устаревшая или вообще отсутствует, то использовать эту библиотеку будет очень сложно, т.к. придется самостоятельно разбираться в её исходном коде и смотреть как она работает. В общем, качественная документация – это очень важно.  

Второе важное качество библиотеки – это её пользовательская база. Т.е. много ли программистов уже используют это решение.  
Как узнать этот показатель? Можно ориентироваться на количество звезд на гитхабе, количество результатов в гугле при поиске, тренды того же гугла.  
Почему нам это должно быть важно? Дело в том, что чем больше у библиотеки пользователей, тем проще будет найти ответ в затруднительной ситуации или разобраться в особенностях использования.  

Последний критерий, определяющий правильный выбор библиотеки – это набор предлагаемых ей возможностей. Для решения одно задачи, как правило, существует несколько библиотек-конкурентов. 
И отличаются они не только документацией и пользовательской базой, но и общей функциональностью. Чтобы не забивать гвозди микроскопом постарайтесь определить, не будет ли выбранное решение слишком избыточным и громоздким для целей программиста. И если это так, то, возможно, лучше найти более простое решение.

## Пример подключения и использования библиотеки

Работа с библиотекой состоит из трёх шагов: установка, подключение и использование.  
Заходишь на сайт с библиотекой, загружаешь архив и распаковываешь его в свою папку, где лежат PHP-сценарии.  
Затем необходимо подключить сценарии с классами библиотеки. Далее в своём коде просто происходит создание новых объектов этих классов и вызов их методов. Такая процедура работы типична для любой библиотеки. 

### Зависимости библиотеки

Итак, мы используем библиотеки, чтобы писать меньше кода и сосредоточиться на главном. Ирония состоит в том, что авторы библиотек поступают точно также. В коде библиотек они сами используют другие библиотеки для облегчения своей работы.  

Вот пример: мы скачали библиотеку «А», а она, в свою очередь, использует библиотеку «Б». При этом код библиотеки «Б» мы не загружали и не устанавливали. Тогда библиотекой «А» воспользоваться не получится, потому что она не будет работать, пока дополнительно не установить библиотеку «Б». 
Такие отношения между библиотеками называются зависимостями.  

Всё еще больше усложняется, когда зависимость включает не только название библиотеки, но и конкретную версию.

# Пакетный менеджер

Пакетный менеджер - это программа для поиска и установки библиотек по их названию.  

Пакетный менеджер избавляет от необходимости самостоятельно искать библиотеки, скачивать, распаковывать, разрешать зависимости – все эти задачи он берет на себя.  

## Что умеет пакетный менеджер

- скачивать и распаковывать библиотеки по их имени
- **автоматически скачивать и устанавливать зависимости каждой библиотеки**
- подключать классы библиотек внутри сценариев
- обновлять библиотеки вместе с зависимостями

## Composer: пакетный менеджер для PHP

В мире PHP для управления библиотеками используется пакетный менеджер под названием Composer. Это мощный и удобный в использовании инструмент, который позволит навсегда забыть про головную боль, связанную с поиском, установкой и разрешением зависимостей у библиотек. 

### Как начать работу с Composer

Потребуется выполнить следующий список действий:

- скачать сам Composer
- выполнить его инициализацию в проекте
- подключить в нужный сценарии файл автозагрузки
- установить необходимую библиотеку

**Установка**  

Скачай Composer для Windows по этой прямой ссылке: [https://getcomposer.org/Composer-Setup.exe](https://getcomposer.org/Composer-Setup.exe)   
Это обычный установщик с режимом "мастера", который проведет по всему процессу установки. По её окончанию можно будет проверить его работу, открыв командную строку. Если выполнить команду `composer`, то результатом будет длинный перечень его возможностей.  

**Инициализация в проекте**  

Продолжаем работу в командной строке. Здесь вначале перейдем в рабочую папку проекта (например так: `cd C:\ospanel\domains\localhost`). Теперь выполним последовательно команды `composer init` и `composer install`.  На этом инициализация закончена. Можно заметить, что в проекте появилась новая папка с именем `vendor`. 

**Подключение сценария автозагрузки**  

Composer упрощает не только установку библиотек, но и их использование. Он берет на себя подключение всех необходимых файлов классов библиотеки. За это отвечает специальный сценарий `autoload.php`.  
Сценарий autoload.php — это единственный файл, который необходимо подключить для использования любых библиотек.  

autoload.php использует механизм «автозагрузки». Он перехватывет обращение к классам библиотек и подключает все необходимые сценарии.  Чтобы это всё работало подключите его в своём сценарии: 
```
require_once "vendor/autoload.php";
```

### Установка библиотеки из Composer

Composer скачивает и устанавливает библиотеки по их имени. Это очевидным образом означает, что вначале нужную библиотеку надо "нагуглить", перейти на её сайт и найти там в описании её имя. Например название библиотеки может быть таким: `fzaninotto/faker`  

Теперь мы можем попросить composer установить библиотеку. Делается это командой: `composer require <имя библиотеки>`. Выполнится загрузка и установка библиотеки в папку `vendor`. Осталось только подключить установленную библиотеку в сценарии и можно её использовать.

### Подключение библиотеки в сценариях

Рассмотрим процесс подключения и использования на примере библиотеки для валидации форм - `GUMP`. 
Вначале установим её командой: `composer require wixel/gump`.  
В сценарии, где происходит валидация формы, подключим её: 
```
<?php
require 'vendor/autoload.php';

$rules = [
	'email' => 'required|valid_email',
	'password' => 'required|min_len,8',
	'login' => 'required|alpha_numeric',
	'phone' => 'phone_number'
];

$gump = new GUMP('ru');
$gump->validation_rules($rules);
$validated_data = $gump->run($_POST);
```

Здесь вначале подключается универсальный файл автозагрузки, который отвечает за подключение классов библиотеки: `vendor/autoload.php`. 

Затем создаётся новый объект валидатора и вызываются его методы для передачи правил валидации и выполнении непосредственно проверки формы. На этом всё.