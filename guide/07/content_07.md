---
layout: page
title: "Раздел 7 - Теория ООП и использование в PHP"
permalink: content-07
---

## Что такое процедурный подход
До сих пор, весь код написанный вами во время выполнения заданий из учебного и личного проектов использовал так
называемый процедурный подход.
При процедурном программировании код размещается в полностью отдельных функциях или процедурах. Эти функции могут
вызывать друг друга и быть вложенными. Данные размещаются в отдельных структурах - массивы, переменные,
а манипуляции с ними осуществляются с помощью этих функций или процедур.  

## Проблемы процедурного подхода
Сама по себе процедурный подход в программировании не является чем то плохим или неправильным. Можно написать прекрасные
сценарии и целые веб-сайты, работая только с функциями. Так, например, популярные системы управления контентом Wordpress
и Drupal (до восьмой версии) используют только процедурную парадигму.   

При структурном программировании данные зачастую отделяются от процедур и являются глобальными, благодаря чему их легко
модифицировать вне области видимости вашего кода. Это означает, что доступ к данным неконтролируемый и непредсказуемый
(то есть у множества функций может быть доступ к глобальным данным).
Кроме того, используя только функции сложно написать большое приложение, потому что, во-первых, функции сами по себе
являются лишь "преобразователями данных", черным ящиком, который принимает некоторые данные на входе, выполняет операции
и возвращает результат. функции ничего не говорят о структуре приложения.  

Вторая проблема состоит в ограниченной возможности повторного использования кода при структурном проектировании: вы
можете только один раз написать функцию, а затем применять её где это нужно.

## Принципы хорошего проектирования
Есть два основополагающих принципа проектирования хорошего кода:

**Прницип первый: не повторяйся**  
Каждый раз, когда программист пишет код и видит, что подобная функциональность уже была полностью или частично
реализована им ранее, это означает необходимость найти такой участок кода и выделить его в отдельную функцию.

**Принцип второй: не усложняй без необходимости**  
В области проектирования простота должна быть одной из ключевых целей и следует избегать ненужной сложности.
Этот принцип говорит о стремлении писать код максимально очевидным образом, а также делать ваши функции максимально
короткими и простыми.  

Методология ООП эффективно помогает разработчику следовать обоим этим принципам.

# Определение ООП
ООП означает Объектно Ориентированное Программирование.  
Из определения понятно, что ключевая особенность ООП - это использование так называемых объектов, которые в этой
методологии ставятся во главу угла.  

## Что есть объект
Хорошая новость в том, что люди уже мыслят в терминах объектов, поэтому такое понятие должно быть интуитивно понятно
каждому.   

Например, когда вы смотрите на какого-то человека, вы видите его как объект.
При этом объект определяется двумя компонентами: атрибутами и поведением. У человека имеются такие атрибуты, как цвет
глаз, возраст, вес и т. д. Человек также обладает поведением, то есть он ходит, говорит, дышит и т. д. В соответствии
со своим базовым определением объект — это сущность, одновременно содержащая данные и поведения.  

В программировании объект - это сущность, которая одновременно содержит _данные_ и _поведение_.  
Данные в объекте - это набор свойств. Свойство объекта можно понимать как переменную, которая существует и принадлежит
только этому объекту.  
Поведение - это набор методов. Метод объекта - это функция, которая так же как и свойство относится только к своему
объекту.  

Объекты — это строительные блоки объектно-ориентированных программ.

# Отличие ООП подхода от процедурного
При процедурном программировании данные, как правило, отделены от поведения - функций, работающих с этими данными.  
При объектно-ориентированном проектировании данные и поведение размещается одновременно в рамках одного объекта.  
Слово «одновременно» в данном случае определяет ключевую разницу между объектно-ориентированным программированием и
процедурном.  

Процедурная методология зачастую предполагает работу с глобальными данными, а в правильно спроектированной ООП
программе вообще не будет такого понятия как глобальные данные.

## Моделирование реального мира
Как было сказано ранее, ООП отлично подходит для моделирования реального мира.  
Концепция объектов хорошо работает, когда нужно выразить в программном коде объекты из реальной жизни, их свойства,
поведение и отношения.

# Принципы ООП
Но ООП код - это не только код, использующий объекты.  
Так, PHP сценарий может использовать множество разных объектов, но назвать его в полной мере объектно ориентированным
можно только если сами эти объекты, их структура и отношения друг с другом следуют нескольким важным принципам ООП.

## Инкапсуляция
Одно из основных преимуществ использования объектов заключается в том, что объекту не нужно показывать все свои свойства
и поведения. При хорошем объектно-ориентированном проектировании объект должен показывать только интерфейсы, необходимые
другим объектам для взаимодействия с ним.  

Дело в том, что при определении свойств и методов объекта, ООП язык дает возможность указать так называемый модификатор
доступа для кажого свойства/метода.  
Модификатор доступа определяет будет ли доступно это свойство или метод для вызова другими объектами (публичный) или же
только доступ к нему будет возможен только изнутри самого объекта (приватный).

Инкапсуляция определяется тем, что объекты содержат как свойства, так и поведения. Скрытие данных является основной
частью инкапсуляции.

### Важность сокрытия реализации
Возникает вопрос: зачем нужны эти модификаторы доступа и почему нельзя все свойства объекта просто сделать публичными?  
Смысл состоит в том, чтобы не давать доступ внешнему коду к реализации внутренних свойств и методов объекта.  
Например, объект, который применяется для вычисления квадратов чисел, должен обеспечивать способ для получения
результатов. Однако внутренние свойства и алгоритмы, используемые для вычисления квадратов чисел, не нужно
делать доступными для запрашивающего объекта.

## Интерфейс и реализация
Интерфейсом объекта в ООП называется набор публичных свойств и методов. Интерфейс определяет основные средства
коммуникации между объектами.

В реальном мире многие вещи тоже имеют свой интерфейс. Например, традиционный калькулятор предлагает следующий интерфейс:  
- кнопки для ввода чисел и операторов
- дисплей для получения результата

Если бы мы проектировали объект, умеющий как настоящий калькулятор выполнять арифметические операции с числами, то у
этого объекта был бы следующий интерфейс:  
- публичный метод для каждой из арифмитеческих операций
- публичный метод для получения результата

Заметьте, что здесь никак не описано строение внутренней реализации, потому что в интерфейс объекта входят только свойства
и методы, доступные публично.

### Реализация
Только открытые атрибуты и свойства являются частью интерфейсов.  
Пользователи не должны видеть какую-либо часть внутренней реализации и могут взаимодействовать с объектами
исключительно через интерфейсы.  
Клиентский код, работая с вашим объектом, не должен знать как внутри объекта реализовано выполнение нужной ему работы.
Все, что нужно знать вызывающему коду - это интерфейс интересуемого объекта, т.е. как последний предлагает с собой
взаимодействовать.  
Так, клиентскому коду будет абсолютно все равно как объект-калькулятор вычисляет результат, до тех пор, пока он верный.

## Наследование
Одной из наиболее сильных сторон объектно-ориентированного программирования, пожалуй, является повторное использование
кода.  
ООП позволяет вам определять отношения между объектами, которые не только облегчают повторное использование кода,
но и способствуют созданию лучшей общей конструкции путем упорядочения и учета общности разнообразных объектов.
Основное средство обеспечения такой функциональности — наследование.

Наследование - это способность объекта наследовать свойства и методы другого объекта.  
Возьмем два объекта: "А" и "B". Пусть в объекте "А" будет несколько свойств. 
Если для пустого объекта "В" определить отношение наследования с "А", то он автоматически получит все свойства своего 
предка, но при этом может иметь и свои собственные.  

Наследование полезно для определения и абстрагирования функциональности и позволяет реализовать дополнительные 
возможности в похожих объектах без необходимости реализовывать всю общую функциональность.

### Альтернатива наследованию
Наследование - это не единственный способ связывать объекты для использования общей функциональности.  
На практике бывает удобнее не наследовать объект, а использовать его как часть другого объекта. Такая связь объектов
называется **композицией**.  

Композиция - это включение одного объекта в состав другого.  
Объект "В" не будет наследовать объект "А". Вместо этого он сделает весь объект "В" одним из своих свойств.  
Такой подход более гибок по сравнению с наследованием, потому что позволяет установить связь сразу с несколькими 
объектами и использовать из них только необходимые свойства/методы. 

## Классы и объекты
В центре ООП находятся объекты. В этом разделе также шла речь только об объектах. Но в классических ООП языках (к ним 
относится и PHP) объекты не могут существовать сами по себе. Любой объект может быть создан только на основе **класса**.  

**Класс** - это базовое понятие в объектно-ориентированном программировании.  
Класс можно рассматривать как тип данных, а объект - как переменную. Представляйте класс как чертеж, описание, на основе
которого создаются объекты. Именно в классе определется весь набор свойств и методов.
  
Объект - это экземпляр класса. У одного класса может быть множество его экземпляров - объектов.  
Запомните: класс - это абстрактный тип данных, который описывает характеристики одной сущности, а объект - это уже 
конкретный представитель класса.

# Поддержка ООП в PHP

## Классы и объекты
Разработка по методологии ООП в PHP начинается с определения классов.  
Описание классов в PHP начинаются служебным словом class:  
```
class Имя_класса {
  // набор свойств и методов
}
```
Название класса принято писать со строчной буквы. Требования к именование такие же как для переменных, за исключением 
знака `$` в начале имени.  
Также следуйте правилу: одному классу один php-сценарий. Имя сценария равно имени класса.  

Для объявления объекта необходимо использовать оператор **new**:
```
$имя_Объекта = new Имя_класса();
```

## Свойства и методы

Свойства - это переменные уровня класса.  
Методы - это функции уровня класса.  

Свойства и методы описываются внутри класса, друг за другом. Сначала идет описание свойств, а затем методов:  
```
class Foo {

    // это публичное свойство с именем `bar`
    public $bar = 1;
    
    // это приватное свойство с именем `baz`
    private $baz = null;  
    
    // это публичный метод с именем `foobar`
    protected function foobar() {
        print ($this->bar);
        print ($this->baz);
    } 
}
```

Имя каждого свойства/метода предваряет **модификатор доступа** (public, private, protected).  
Модификатор доступа указывает на область видимости этого свойства/метода.  
Так, значение публичного свойства `bar` можно прочитать из внешнего кода: обратиться к этому свойству объекта - 
экземпляра данного класса:  
```
$foo = new Foo();
print($foo->bar); // 1
```
Модификаторы доступа private и protected разрешают доступ только внутри самого класса. protected дополнительно разрешает
доступ всем наследникам класса.  

### Доступ к свойствам и методам
Посмотрите на предыдущие примеры кода. Обратите внимание как выглядит доступ к свойствам и методам: в PHP для этого 
предназначен оператор специальный оператор `->`. В других ООП языках (JavaScript) для тех же целей используется оператор
точка `.`.  

Обращение к свойствам protected и private возможно только внутри их класса.  
В методе `foobar` демонстрируется этот способ: метод обращается к свойствам своего класса с помощью специальной 
переменной `$this`.  
`$this` - это специальный указатель, который всегда относится к текущему объекту.

## Конструктор класса
Конструктор класса - это специальный метод, который будет автоматически вызван во время создания нового экземпляра этого
класса.  
В конструкторе удобно размещать код, ответственный за инициализацию нового объекта стартовыми значениями.  
Этот пример демонстрирует класс с конструктором, который установит значения паре свойств при создании объекта:  
```
class Foo {
    private $bar;
    private $baz;
    
    public function __construct() {
        $this->bar = 1;
        $this->baz = 2;
    }
}
```
Имя метода-конструктора обязательно должно быть `__construct`. Только тогда он будет вызван автоматически.

## Наследование классов
В PHP наследование работает на уровне классов. Это означает, что отношение наследования следует указывать в описании 
самого класса.  
За наследование отвечает ключевое слово **extends**.  
Создадим два класса: A и В.  
Класс A будет базовым, т.е. родительским для дочернего класса В. Иногда базовый класс также называют суперклассом, а 
дочерний — подкласcом.

```
class A {
    protected $bar = "hello world";
}

class B extends A {
    protected $baz = 2;

    public function __construct() {
        print($this->bar);
    }
}

$b = new B(); // hello world
```